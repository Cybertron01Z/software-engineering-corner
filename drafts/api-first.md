---
title: Effortless API-first 
subtitle: Using OpenAPI Generator's latest multiple spec-file feature âœ¨
slug: api-first-development
tags: api, rest-api, openapi, gradle, api-first
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1690024103909/5Im8zw6FL.jpg?auto=format
domain: software-engineering-corner.hashnode.dev
ignorePost: true
hideFromHashnodeCommunity: false
publishAs: romanutti
---

The software development world is an ever-evolving landscape. New technologies and methodologies are perpetually surfacing, each promising a more efficient and effective way to create high-quality software. One such approach that is gaining significant traction is API-first development.

This article describes the API-first approach, and [how the latest openapi-generator-gradle-plugin version now allows you to have multiple specification files](####OpenAPI-Generator).

### What does API-first mean?

API-first design is a development paradigm that prioritizes your APIs and how your different software pieces communicate with each other, at the top of your project's needs. In this approach, APIs are designed before any line of code is written.

To outline how the API should act, we use [OpenAPI Specification](https://spec.openapis.org/oas/v3.1.0). Following this standard, we can define endpoints, operations, parameters, error messages, and other information in a way that both humans and computers understand.

### The benefits of API-first development

[TODO] Further describe each example

* Development teams can work in parallel

* Code-generation

* Integration tested


### The tools

#### Swagger Editor

#### OpenAPI Generator

openapi/user-api.yaml

```yaml
openapi: 3.0.0
info:
  version: 1.0.0
  title: User API
  description: API to manage users
paths:
  /users:
    get:
      summary: Get list of users
      responses:
        '200':
          description: OK
```

openapi/order-api.yaml

```yaml
openapi: 3.0.0
info:
  version: 1.0.0
  title: Order API
  description: API to manage orders
paths:
  /orders:
    get:
      summary: Get list of orders
      responses:
        '200':
          description: OK
```

```kotlin
plugins {
    id("org.openapi.generator") version "7.0.0-beta"
}
```

```kotlin
openApiGenerate {
    generatorName.set("spring") // TODO: FE
    inputSpecRootDirectory.set("$rootDir/openapi")
    outputDir.set("$buildDir/generated")
    configFile.set("$rootDir/api-config.json")
}
```

```java
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.0.0-beta).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.api;

import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2023-07-22T12:12:39.823042+02:00[Europe/Zurich]")
@Validated
@Tag(name = "users", description = "the users API")
public interface UsersApi {

    default Optional<NativeWebRequest> getRequest() {
        return Optional.empty();
    }

    /**
     * GET /users : Get list of users
     *
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "usersGet",
        summary = "Get list of users",
        responses = {
            @ApiResponse(responseCode = "200", description = "OK")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/users"
    )
    default ResponseEntity<Void> usersGet(
        
    ) {
        return new ResponseEntity<>(HttpStatus.NOT_IMPLEMENTED);

    }
}
```

### APIs as "first-class" citizens

An API-first approach to building software can benefit your organization in many ways. However, keep in mind that just using and adopting the tools is not enough. The API-first approach requires embracing a new process - and even more crucial: A shift from thinking in code to a code-agnostic way to design your APIs.